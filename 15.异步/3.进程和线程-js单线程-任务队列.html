<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <script>
    /*
      进程（process）：计算机已经运行的程序，是操作系统管理程序的一种方式
      线程（thread）：操作系统能够运行运算调度的最小单位，通常情况下他被包含进程中
      
      具体就是：
        进程：我们可以认为，启动一个应用程序，就会默认启动一个进程
        线程：每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称为主线程
        我们也可以说进程是线程的容器

        可以类比操作系统类似于一个大工厂
          工厂里有很多车间，这个车间就是进程
            每个车间里有一个或以上的工人在工作，一个工人就是一个线程

        操作系统是如何做到让多个进程同时工作的呢？
          因为CPU的运算速度非常快，它可以在多个进程之间快速切换（假如一个单核的CPU）
            当我们进程中的线程获取到时间片时，就可以快速执行我们编写的代码
              对于用户来说是感受不到这种快速的切换的
    */

    /*
      JS是单线程的语言，JS的线程是有自己的容器进程的：浏览器或者Node
        浏览器是一个进程吗？浏览器的一个进程里有多少个线程？
          目前多数的浏览器都是多进程的，当我们打开一个tab的时候就会开启一个进程，这是为了防止一个页面卡死，所有的页面都不能响应
            每个进程又有很多个线程，其中包括一个专门执行JavaScript代码的线程
              JS代码的执行是在一个单独的线程中执行的
                意味着JS代码同一时刻只能做一件事
                  如果这件事（比如执行某个函数）是十分耗时的，也就意味着当前的线程会被阻塞
                    因此真正耗时的操作实际上，并不是由js线程在执行
                      浏览器的每个进程是多线程的，那么其它线程可以来完成这个耗时的操作
                        比如网络请求，定时器，我们只需要在特定的时候执行传入的回调函数即可
    */

    function bar () {
      console.log('bar')
    }
    function foo () {
      console.log('foo')

      /*
        这里的定时操作其实是由浏览器来进行的，
          而不是执行js的线程（如果是由js来进行是会阻塞的），
            也就是说会由浏览器该进程中的另一个线程（非执行JS的线程）来执行，
              那么在计时的过程中，该进程中的js线程就可以继续往下执行其他代码了
                  等到时间后，这个进程会把setTimeout中传入的回调函数（也可以说是一个任务）放到一个任务队列中
                    在把全局的代码执行完后（执行上下文栈为空），会观察任务队列中是否为空，
                      若不为空，将任务队列中所要执行的任务依次压入执行上下文栈中执行（如果是一个函数，其就创建一个新的函数执行上下文在执行上下文栈中，进行处理）
                        浏览器会把DOM监听到事件后所要执行的函数以及AJAX的回调函数也是会被放到任务队列中排队的

      */
      setTimeout(() => { // 并不会阻塞下面的bar()的执行
        console.log('setTimeout')
      }, 10000)

      bar()
      // 执行bar的时候，会生成一个bar函数的执行上下文压入执行上下文栈，此时不是在执行foo了
    }
    foo()
  </script>
</body>

</html>